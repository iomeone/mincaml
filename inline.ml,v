head	1.2;
access;
symbols;
locks
	sumii:1.2; strict;
comment	@; @;


1.2
date	2002.12.04.03.29.49;	author sumii;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.18.07.06.00;	author sumii;	state Exp;
branches;
next	;


desc
@@


1.2
log
@*** empty log message ***
@
text
@open KNormal

let threshold = ref 0

let rec size = function
  | IfEqInt(_, _, e1, e2) -> 1 + size e1 + size e2
  | IfLEInt(_, _, e1, e2) -> 1 + size e1 + size e2
  | LetTuple(_, _, e) -> 1 + size e
  | Let(_, e1, e2) -> 1 + size e1 + size e2
  | LetRec(fundefs, e2) ->
      List.fold_left
	(fun s { body = e1 } -> s + 1 + size e1)
	(size e2)
	fundefs
  | _ -> 1 (* [XXX] error-prone *)

let rec g env = function
  | IfEqInt(x, y, e1, e2) -> IfEqInt(x, y, g env e1, g env e2)
  | IfLEInt(x, y, e1, e2) -> IfLEInt(x, y, g env e1, g env e2)
  | LetTuple(x, y, e) -> LetTuple(x, y, g env e)
  | Let(x, e1, e2) -> Let(x, g env e1, g env e2)
  | LetRec(fundefs, e2) ->
      let env' =
	List.fold_left
	  (fun env' { name = x; args = ys; body = e1 } ->
	    if size e1 > !threshold then env else
	    M.add x (ys, e1) env')
	  env
	  fundefs in
      let fundefs' =
	List.map
	  (fun { name = x; args = ys; body = e1 } ->
	    { name = x; args = ys; body = g env' e1})
	  fundefs in
      LetRec(fundefs', g env' e2)
  | App(x, ys) when M.mem x env ->
      let (args, body) = M.find x env in
      Format.eprintf "inlining %s@@." (fst x);
      let zs = S.elements (fv body) in
      let env' =
	try
	  List.fold_left2
	    (fun env arg y -> M.add arg y env)
	    (M.adds2 zs zs M.empty)
	    args
	    ys
	with Invalid_argument("List.fold_left2") -> assert false in
      Alpha.g env' body
  | e -> e (* [XXX] error-prone *)

let f e = g M.empty e
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
let threshold = ref 100
d6 4
a9 2
  | Let(x, e1, e2) -> 1 + size e1 + size e2
  | Var(x) -> 1
d12 1
a12 2
	(fun s { name = x; args = ys; body = e1 } ->
	  s + 1 + size e1)
d15 1
a15 5
  | App(x, ys) -> 1
  | NegInt(x) -> 1
  | SubInt(x, y) -> 1
  | IfLEInt(x, y, e1, e2) -> 1 + size e1 + size e2
  | Imm(_) -> 1
d17 5
a21 2
let rec f env = function
  | Let(x, e1, e2) -> Let(x, f env e1, f env e2)
d27 1
a27 1
	    FinMap.extend x (ys, e1) env')
d33 1
a33 1
	    { name = x; args = ys; body = f env' e1})
d35 14
a48 16
      LetRec(fundefs', f env' e2)
  | App(x, ys) ->
      (try
	let (args, body) = FinMap.lookup x env in
	let { name = name; args = args; body = body } =
	  Alpha.h FinMap.empty { name = x; args = args; body = body } in
	assert(name = x);
	Format.eprintf "inlining %s@@." (Syntax.ppI x);
	fst (List.fold_left
	       (function
		 | (_, []) -> failwith ("arity mismatch in function application of " ^ Syntax.ppI x)
		 | (e, y :: ys) -> fun arg -> Let(arg, Var(y), e), ys)
	       (body, ys)
	       args)
      with FinMap.Undefined(_) -> App(x, ys))
  | IfLEInt(x, y, e1, e2) -> IfLEInt(x, y, f env e1, f env e2)
d50 2
@
