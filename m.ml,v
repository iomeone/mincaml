head	1.4;
access;
symbols;
locks
	sumii:1.4; strict;
comment	@; @;


1.4
date	2005.01.20.20.02.48;	author sumii;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.01.14.52.41;	author sumii;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.01.08.15.04;	author sumii;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.23.03.52.19;	author sumii;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@(* customized version of Map *)

module type T = sig type t end

module type S =
  sig
    include Map.S
    val add_list : (key * 'a) list -> 'a t -> 'a t
    val add_list2 : key list -> 'a list -> 'a t -> 'a t
  end

module Make : (functor (E : T) -> S with type key = E.t) =
  functor (E : T) ->
    struct
      module M =
	Map.Make
	  (struct
	    type t = E.t
	    let compare = compare
	  end)
      include M
      let add_list xys env =
	List.fold_left (fun env (x, y) -> add x y env) env xys
      let add_list2 xs ys env =
	List.fold_left2 (fun env x y -> add x y env) env xs ys
    end
@


1.3
log
@*** empty log message ***
@
text
@d5 9
a13 2
module Make =
  functor(E : T) ->
d16 5
a20 4
	Map.Make(struct
	  type t = E.t
	  let compare = compare
	end)
d22 4
a25 4
      exception Undefined of E.t
      let find x env =
	try find x env
	with Not_found -> raise(Undefined(x))
@


1.2
log
@*** empty log message ***
@
text
@d3 1
a3 6
module M =
  Map.Make(struct
    type t = Syntax.ident
    let compare = compare
  end)
include M
d5 14
a18 4
exception Undefined of Syntax.ident
let find x env =
  try find x env
  with Not_found -> raise(Undefined(x))
@


1.1
log
@Initial revision
@
text
@d1 2
d8 1
d10 4
a13 10
type ident = Syntax.ident

type 'a t = (ident * 'a) list

let empty = []
let extend x v env = (x, v) :: env
let rec lookup x = function
  | [] -> raise(Not_found)
  | (y, v) :: _ when x = y -> v
  | _ :: env -> lookup x env
@
