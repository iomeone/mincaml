head	1.9;
access;
symbols;
locks
	sumii:1.9; strict;
comment	@; @;


1.9
date	2004.03.12.04.57.45;	author sumii;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.02.10.51.28;	author sumii;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.18.04.18.39;	author sumii;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.23.06.52.30;	author sumii;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.23.04.16.31;	author sumii;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.24.04.15.16;	author sumii;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.15.03.02.28;	author sumii;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.10.06.24.01;	author sumii;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.10.01.31.56;	author sumii;	state Exp;
branches;
next	;


desc
@@


1.9
log
@*** empty log message ***
@
text
@type ident = KNormal.ident
type ident' = KNormal.ident'
type lab = L of string (* for tagging *)
type label = lab * Type.t

module M = KNormal.M
module S = KNormal.S

let pp_label (L(l), _) = l

type closure = { entry : label; actual_fv : ident list }
type t =
  | Var of ident
  | Global of label
  | NegInt of ident
  | AddInt of ident * ident'
  | SubInt of ident * ident'
  | IfEqInt of ident * ident' * t * t
  | IfLEInt of ident * ident' * t * t
  | Tuple of ident list
  | LetTuple of ident list * ident * t
  | Put of ident * ident' * ident
  | Get of ident * ident'
  | Let of ident * t * t
  | MakeCls of (ident * closure) list * t
  | AppCls of ident * ident list
  | AppDir of label * ident list
  | Int of int
  | Float of float
  | Unit
type fundef = { name : label;
		args : ident list;
		formal_fv : ident list;
		body : t }
type prog = Prog of fundef list * t

(* [X] inefficient - expressions should remember their own free variables *)
let fv' = KNormal.fv'
let rec fv = function
  | Var(x) -> S.singleton x
  | Global(l) -> S.empty
  | NegInt(x) -> S.singleton x
  | AddInt(x, y) -> S.add x (fv' y)
  | SubInt(x, y) -> S.add x (fv' y)
  | IfEqInt(x, y, e1, e2) ->
      S.add x (S.union (fv' y) (S.union (fv e1) (fv e2)))
  | IfLEInt(x, y, e1, e2) ->
      S.add x (S.union (fv' y) (S.union (fv e1) (fv e2)))
  | Tuple(xs) -> S.of_list xs;
  | LetTuple(xs, y, e) -> S.add y (S.diff (fv e) (S.of_list xs))
  | Put(x, y, z) -> S.add x (S.add z (fv' y))
  | Get(x, y) -> S.add x (fv' y)
  | Let(x, e1, e2) -> S.union (fv e1) (S.remove x (fv e2))
  | MakeCls(bindings, e) ->
      let (fs, xss) =
	List.fold_left
	  (fun (fs, xss) (f, { entry = _; actual_fv = xs }) ->
	    (S.add f fs, S.union xss (S.of_list xs)))
	  (S.empty, S.empty)
	  bindings in
      S.diff (S.union xss (fv e)) fs
  | AppCls(f, xs) -> S.of_list (f :: xs)
  | AppDir(_, xs) -> S.of_list xs
  | Int(_) -> S.empty
  | Float(_) -> S.empty
  | Unit -> S.empty

let toplevel : fundef list ref = ref []

let lab_of_id (x, t) = (L(x), t)
let lab_of_id' (x, t) = (L("min_caml_" ^ x), t)

let rec g known = function
  | KNormal.Var(x) -> Var(x)
  | KNormal.GlobalArray(x) -> Global(lab_of_id' x)
  | KNormal.ExtFun(x, ys) -> AppDir(lab_of_id' x, ys)
  | KNormal.NegInt(x) -> NegInt(x)
  | KNormal.AddInt(x, y) -> AddInt(x, y)
  | KNormal.SubInt(x, y) -> SubInt(x, y)
  | KNormal.IfEqInt(x, y, e1, e2) ->
      let e1' = g known e1 in
      let e2' = g known e2 in
      IfEqInt(x, y, e1', e2')
  | KNormal.IfLEInt(x, y, e1, e2) ->
      let e1' = g known e1 in
      let e2' = g known e2 in
      IfLEInt(x, y, e1', e2')
  | KNormal.Tuple(xs) -> Tuple(xs)
  | KNormal.LetTuple(xs, y, e) -> LetTuple(xs, y, g known e)
  | KNormal.Put(x, y, z) -> Put(x, y, z)
  | KNormal.Get(x, y) -> Get(x, y)
  | KNormal.Let(x, e1, e2) ->
      let e1' = g known e1 in
      let e2' = g known e2 in
      Let(x, e1', e2')
  | KNormal.LetRec(fundefs, e2) ->
      let toplevel_back = !toplevel in
      let fs = List.map (fun fundef -> fundef.KNormal.name) fundefs in
      let known' = S.union known (S.of_list fs) in
      let e1s' =
	List.map (fun fundef -> g known' fundef.KNormal.body) fundefs in
      let check =
	List.fold_left2
	  (fun check fundef e1' ->
	    check && S.subset (fv e1') (S.of_list fundef.KNormal.args))
	  true
	  fundefs
	  e1s' in
      let known', e1s' =
	if check then known', e1s' else
	known,
	(toplevel := toplevel_back;
	 List.map (fun fundef -> g known fundef.KNormal.body) fundefs) in
      let bindings =
	List.map2
	  (fun { KNormal.name = f; KNormal.args = xs } e1' ->
	    let ys = S.elements (S.diff (fv e1') (S.of_list xs)) in
	    let l = lab_of_id f in
	    toplevel :=
	      { name = l; args = xs; formal_fv = ys; body = e1' } :: !toplevel;
            (f, { entry = l; actual_fv = ys }))
	  fundefs
	  e1s' in
      let e2' = g known' e2 in
      if S.is_empty (S.inter (S.of_list fs) (fv e2')) then
	(Format.eprintf "eliminating closure(s) %s@@." (KNormal.pp_idents fs);
	 e2')
      else MakeCls(bindings, e2')
  | KNormal.App(f, xs) when S.mem f known ->
      Format.eprintf "directly applying %s@@." (fst f);
      AppDir(lab_of_id f, xs)
  | KNormal.App(f, xs) -> AppCls(f, xs)
  | KNormal.Int(i) -> Int(i)
  | KNormal.Float(d) -> Float(d)
  | KNormal.Unit -> Unit

let f e =
  toplevel := [];
  let e' = g S.empty e in
  Prog(!toplevel, e')
@


1.8
log
@*** empty log message ***
@
text
@d2 3
a4 2
type lab = L of string (* for the sake of tagging *)
type label = lab * Type.typ
d9 1
a9 6
let ppL (L(l), _) = l
let ppI = KNormal.ppI
let rec ppB = function
  | [] -> ""
  | [(x, _)] -> ppI x
  | (x, _) :: bindings -> ppI x ^ ", " ^ ppB bindings
d16 4
a19 5
  | AddInt of ident * ident
  | SubInt of ident * ident
  | AddConst of ident * int
  | IfEqInt of ident * ident * t * t
  | IfLEInt of ident * ident * t * t
d22 2
a23 2
  | Put of ident * ident * ident
  | Get of ident * ident
d37 2
a38 1
(* [XXX] inefficient - expressions should remember their own free variables *)
d40 1
a40 1
  | Var(x) -> S.of_list [x]
d42 7
a48 6
  | NegInt(x) -> S.of_list [x]
  | AddInt(x, y) -> S.of_list [x; y]
  | SubInt(x, y) -> S.of_list [x; y]
  | AddConst(x, _) -> S.of_list [x]
  | IfEqInt(x, y, e1, e2) -> S.add x (S.add y (S.union (fv e1) (fv e2)))
  | IfLEInt(x, y, e1, e2) -> S.add x (S.add y (S.union (fv e1) (fv e2)))
d51 2
a52 2
  | Put(x, y, z) -> S.of_list [x; y; z]
  | Get(x, y) -> S.of_list [x; y]
d59 2
a60 1
	  (S.empty, S.empty) bindings in
d70 3
d75 2
a76 1
  | KNormal.Global(x) -> Global(L(ppI x), snd x)
a79 1
  | KNormal.AddConst(x, i) -> AddConst(x, i)
d100 2
d103 11
a113 9
	List.for_all
	  (fun { KNormal.name = f; KNormal.args = xs; KNormal.body = e1 } ->
	    let e1' = g known' e1 in
	    S.for_all
	      (fun y -> Typing.global (fst y) || List.mem y xs)
	      (fv e1'))
	  fundefs in
      let known = if check then known' else known in
      toplevel := toplevel_back;
d115 6
a120 11
	List.map
	  (fun { KNormal.name = f; KNormal.args = xs; KNormal.body = e1 } ->
	    let e1' = g known e1 in
	    let ys =
	      S.elements
		(S.filter
		   (fun y -> not (Typing.global (fst y) || List.mem y xs))
		   (fv e1')) in
	    let l = (L(ppI f), snd f) in
	    let fundef = { name = l; args = xs; formal_fv = ys; body = e1' } in
	    toplevel := fundef :: !toplevel;
d122 11
a132 11
	  fundefs in
      let e2' = g known e2 in
      if List.exists (fun (f, _) -> S.mem f (fv e2')) bindings
      then MakeCls(bindings, e2')
      else (Format.eprintf "eliminating closure(s) %s@@." (ppB bindings); e2')
  | KNormal.App(f, xs) ->
      if S.mem f known then
	(Format.eprintf "directly applying %s@@." (ppI f);
	 AppDir((L(ppI f), snd f), xs))
      else 
	AppCls(f, xs)
d139 1
a139 1
  let e' = g (KNormal.fv e) e in
@


1.7
log
@*** empty log message ***
@
text
@d18 1
d45 1
d74 1
d96 13
a108 6
      let free = KNormal.fv (KNormal.LetRec(fundefs, KNormal.Unit)) in
      let known =
	if S.subset free known then
	  let fs = List.map (fun fundef -> fundef.KNormal.name) fundefs in
	  S.union known (S.of_list fs)
	else known in
d110 2
a111 4
	List.fold_right
	  (fun { KNormal.name = f;
		 KNormal.args = xs;
		 KNormal.body = e1 } bindings ->
d113 5
a117 3
	    let ys = S.elements (S.filter
				   (fun y -> not (Typing.global (fst y)))
				   (S.diff (fv e1') (S.of_list xs))) in
a119 1
	    let binding = (f, { entry = l; actual_fv = ys }) in
d121 2
a122 2
            (binding :: bindings))
	  fundefs [] in
d128 4
a131 4
      if S.mem f known then begin
	Format.eprintf "directly applying %s@@." (ppI f);
	AppDir((L(ppI f), snd f), xs)
      end else
@


1.6
log
@going to remove pp
@
text
@d1 3
a3 2
module S = Syntax.IdSet
type ident = Syntax.ident
d5 2
a6 2
type label = L of string
let ppL (L(l)) = "L" ^ l
d8 8
a15 4
type closure = { entry : ident; actual_fv : ident list }
type ident_or_sint =
  | Ident of ident
  | SInt of int
d18 10
a27 3
  | NegInt of ident_or_sint
  | SubInt of ident * ident_or_sint
  | IfLEInt of ident * ident_or_sint * t * t
d29 6
a34 5
  | LetRec of (ident * closure) list * t
  | App of ident * ident list
  | DApp of label * ident list
  | Imm of Syntax.imm
  | Label of label
a40 49
let ppI = Syntax.ppI
let ppIS = function
  | Ident(x) -> ppI x
  | SInt(i) -> string_of_int i
let rec ppB = function
  | [] -> ""
  | [(x, _)] -> ppI x
  | (x, _) :: bindings -> ppI x ^ ", " ^ ppB bindings
let rec ppIs = function
  | [] -> ""
  | [x] -> ppI x
  | x :: xs -> ppI x ^ ", " ^ ppIs xs
let rec pp_binding (x, { entry = y; actual_fv = zs }) =
  Printf.sprintf "%s = (%s, [%s])" (ppI x) (ppI y) (ppIs zs)
let rec pp_bindings = function
  | [] -> ""
  | [binding] -> pp_binding binding
  | binding :: bindings ->
      pp_binding binding ^ "\nand " ^ pp_bindings bindings
let rec pp = function
  | Var(x) -> ppI x
  | NegInt(x) ->
      Printf.sprintf "-%s" (ppIS x)
  | SubInt(x, y) ->
      Printf.sprintf "%s - %s" (ppI x) (ppIS y)
  | IfLEInt(x, y, e1, e2) ->
      Printf.sprintf "if %s <= %s then %s else\n%s"
	(ppI x) (ppIS y) (pp e1) (pp e2)
  | Let(x, e1, e2) ->
      Printf.sprintf "let %s = %s in\n%s" (ppI x) (pp e1) (pp e2)
  | LetRec(bindings, e2) ->
      Printf.sprintf "let rec %s in\n%s" (pp_bindings bindings) (pp e2)
  | App(x, ys) ->
      Printf.sprintf "apply_closure %s (%s)" (ppI x) (ppIs ys)
  | DApp(x, ys) ->
      Printf.sprintf "apply_direct %s (%s)" (ppL x) (ppIs ys)
  | Imm(Syntax.Int(i)) -> string_of_int i
  | Imm(Syntax.Float(f)) -> string_of_float f
  | Label(l) -> ppL l
let pp_fundef { name = x; args = ys; formal_fv = zs; body = e } =
  Printf.sprintf "%s (%s) [%s] =\n%s" (ppL x) (ppIs ys) (ppIs zs) (pp e)
let rec pp_fundefs = function
  | [] -> ""
  | [fundef] -> pp_fundef fundef
  | fundef :: fundefs ->
      Printf.sprintf "%s\nand %s" (pp_fundef fundef) (pp_fundefs fundefs)
let pp_prog (Prog(fundefs, e)) =
  Printf.sprintf "let rec %s in\n(* min_caml_main *)\n%s" (pp_fundefs fundefs) (pp e)

d43 11
a53 9
  | Var(x) -> S.from_list [x]
  | NegInt(Ident(x)) -> S.from_list [x]
  | NegInt(SInt(_)) -> S.empty
  | SubInt(x, Ident(y)) -> S.from_list [x; y]
  | SubInt(x, SInt(_)) -> S.from_list [x]
  | IfLEInt(x, Ident(y), e1, e2) ->
      S.add x (S.add y (S.union (fv e1) (fv e2)))
  | IfLEInt(x, SInt(_), e1, e2) ->
      S.add x (S.union (fv e1) (fv e2))
d55 2
a56 2
  | LetRec(bindings, e) ->
      let (xs, yzs) =
d58 9
a66 14
	  (fun (xs, yzs) (x, { entry = y; actual_fv = zs }) ->
	    (S.add x xs,
	     S.union yzs (S.from_list (y :: zs))))
	  (S.empty, S.empty)
	  bindings in
      S.diff (S.union yzs (fv e)) xs
  | App(x, ys) -> S.from_list (x :: ys)
  | DApp(_, ys) -> S.from_list ys
  | Imm(_) -> S.empty
  | Label(_) -> S.empty

let g = function
  | KNormal.Ident(x) -> Ident(x)
  | KNormal.SInt(i) -> SInt(i)
d70 1
a70 1
let rec f' known = function
d72 8
a79 2
  | KNormal.NegInt(x) -> NegInt(g x)
  | KNormal.SubInt(x, y) -> SubInt(x, g y)
d81 7
a87 3
      let e1' = f' known e1 in
      let e2' = f' known e2 in
      IfLEInt(x, g y, e1', e2')
d89 2
a90 2
      let e1' = f' known e1 in
      let e2' = f' known e2 in
d93 2
a94 3
      let dummy = KNormal.Imm(Syntax.Int(0)) in (* tenuki *)
      let free = KNormal.fv (KNormal.LetRec(fundefs, dummy)) in
      let known' =
d96 2
a97 5
	  S.union known
	    (S.from_list
	       (List.map
		  (fun { KNormal.name = x } -> x)
		  fundefs))
d99 1
a99 1
      let (bindings, env) =
d101 1
a101 1
	  (fun { KNormal.name = f; 
d103 8
a110 12
		 KNormal.body = e1 } (bindings, env) ->
	    let e1' = f' known' e1 in
	    let zs = S.elements (S.diff
				   (fv e1')
				   (S.from_list xs)) in
	    let l = L(Syntax.ppI f) in
	    let fundef = { name = l;
			   args = xs;
			   formal_fv = zs;
			   body = e1' } in
	    let x' = Syntax.I("L" ^ Syntax.ppI f) in
	    let binding = (f, { entry = x'; actual_fv = zs }) in
d112 6
a117 14
            (binding :: bindings,
	     (x', l) :: env))
	  fundefs
	  ([], []) in
      let e2' = f' known' e2 in
      if List.exists (fun (f, _) -> S.mem f (fv e2')) bindings then
	List.fold_right
	  (fun (x', l) e -> Let(x', Label(l), e))
	  env
	  (LetRec(bindings, e2'))
      else begin
	Format.eprintf "eliminating closure %s@@." (ppB bindings);
	e2'
      end
d119 8
a126 5
      if S.mem f known then
	DApp(L(Syntax.ppI f), xs)
      else
	App(f, xs)
  | KNormal.Imm(m) -> Imm(m)
d130 1
a130 1
  let e' = f' S.empty e in
@


1.5
log
@going to stop generalization
@
text
@d2 1
d7 3
a9 4
(* generalize for the sake of convenience in register assignment/allocation *)
type 'a closure = { entry : 'a; actual_fv : 'a list }
type 'a ident_or_sint =
  | Ident of 'a
d11 10
a20 5
type 'a t =
  | Let of 'a * 'a t * 'a t
  | LetRec of ('a * 'a closure) list * 'a t
  | IfLEInt of 'a * 'a ident_or_sint * 'a t * 'a t
  | Var of 'a
d22 5
a26 10
  | App of 'a * 'a list
  | DApp of label * 'a list
  | NegInt of 'a ident_or_sint
  | SubInt of 'a * 'a ident_or_sint
  | Imm of Syntax.imm
type 'a fundef = { name : label;
		   args : 'a list;
		   formal_fv : 'a list;
		   body : 'a t }
type 'a prog = Prog of 'a fundef list * 'a t
d28 2
a29 1
let ppIS ppI = function
d32 1
a32 2

let rec ppB pp = function
d34 3
a36 4
  | [(x, _)] -> pp x
  | (x, _) :: bindings -> pp x ^ ", " ^ ppB pp bindings

let rec pp_idents pp_ident = function
d38 5
a42 5
  | [x] -> pp_ident x
  | x :: xs -> pp_ident x ^ ", " ^ pp_idents pp_ident xs
let rec pp_binding pp_ident (x, { entry = y; actual_fv = zs }) =
  Printf.sprintf "%s = (%s, [%s])" (pp_ident x) (pp_ident y) (pp_idents pp_ident zs)
let rec pp_bindings pp_ident = function
d44 1
a44 1
  | [binding] -> pp_binding pp_ident binding
d46 10
a55 2
      pp_binding pp_ident binding ^ "\nand " ^ pp_bindings pp_ident bindings
let rec pp pp_ident = function
d57 1
a57 2
      Printf.sprintf "let %s = %s in\n%s" (pp_ident x) (pp pp_ident e1) (pp pp_ident e2)
  | Var(x) -> pp_ident x
d59 1
a59 1
      Printf.sprintf "let rec %s in\n%s" (pp_bindings pp_ident bindings) (pp pp_ident e2)
d61 1
a61 1
      Printf.sprintf "apply_closure %s (%s)" (pp_ident x) (pp_idents pp_ident ys)
d63 1
a63 8
      Printf.sprintf "apply_direct %s (%s)" (ppL x) (pp_idents pp_ident ys)
  | NegInt(x) ->
      Printf.sprintf "-%s" (ppIS pp_ident x)
  | SubInt(x, y) ->
      Printf.sprintf "%s - %s" (pp_ident x) (ppIS pp_ident y)
  | IfLEInt(x, y, e1, e2) ->
      Printf.sprintf "if %s <= %s then %s else\n%s"
	(pp_ident x) (ppIS pp_ident y) (pp pp_ident e1) (pp pp_ident e2)
d67 3
a69 3
let pp_fundef pp_ident { name = x; args = ys; formal_fv = zs; body = e } =
  Printf.sprintf "%s (%s) [%s] =\n%s" (ppL x) (pp_idents pp_ident ys) (pp_idents pp_ident zs) (pp pp_ident e)
let rec pp_fundefs pp_ident = function
d71 5
a75 4
  | [fundef] -> pp_fundef pp_ident fundef
  | fundef :: fundefs -> Printf.sprintf "%s\nand %s" (pp_fundef pp_ident fundef) (pp_fundefs pp_ident fundefs)
let pp_prog pp_ident (Prog(fundefs, e)) =
  Printf.sprintf "let rec %s in\n(* min_caml_main *)\n%s" (pp_fundefs pp_ident fundefs) (pp pp_ident e)
d79 9
a97 2
  | Var(x) -> S.from_list [x]
  | Label(_) -> S.empty
a99 8
  | NegInt(Ident(x)) -> S.from_list [x]
  | NegInt(SInt(_)) -> S.empty
  | SubInt(x, Ident(y)) -> S.from_list [x; y]
  | SubInt(x, SInt(_)) -> S.from_list [x]
  | IfLEInt(x, Ident(y), e1, e2) ->
      S.add x (S.add y (S.union (fv e1) (fv e2)))
  | IfLEInt(x, SInt(_), e1, e2) ->
      S.add x (S.union (fv e1) (fv e2))
d101 1
d107 10
a116 1
let rec f known = function
d118 3
a120 3
      let Prog(fundefs1, e1') = f known e1 in
      let Prog(fundefs2, e2') = f known e2 in
      Prog(fundefs1 @@ fundefs2, Let(x, e1', e2'))
d125 1
a125 1
	if S.diff free known = S.empty then
d132 1
a132 1
      let (fundefs1s, bindings, env) =
d134 4
a137 4
	  (fun { KNormal.name = x; 
		 KNormal.args = ys;
		 KNormal.body = e1 } (fundefs1s, bindings, env) ->
	    let Prog(fundefs1, e1') = f known' e1 in
d140 2
a141 2
				   (S.from_list ys)) in
	    let l = L(Syntax.ppI x) in
d143 1
a143 1
			   args = ys;
d146 4
a149 4
	    let x' = Syntax.I("L" ^ Syntax.ppI x) in
	    let binding = (x, { entry = x'; actual_fv = zs }) in
            (fundef :: fundefs1 @@ fundefs1s,
	     binding :: bindings,
d152 14
a165 21
	  ([], [], []) in
      let Prog(fundefs2, e2') = f known' e2 in
      let used = List.exists (fun (x, _) -> S.mem x (fv e2')) bindings in
      Prog(fundefs1s @@ fundefs2,
	   if used then
	     List.fold_right
	       (fun (x', l) e -> Let(x', Label(l), e))
	       env
	       (LetRec(bindings, e2'))
	   else begin
	     Format.eprintf "eliminating closure %s@@." (ppB Syntax.ppI bindings);
	     e2'
	   end)
  | KNormal.IfLEInt(x, y, e1, e2) ->
      let Prog(fundefs1, e1') = f known e1 in
      let Prog(fundefs2, e2') = f known e2 in
      Prog(fundefs1 @@ fundefs2, IfLEInt(x, g y, e1', e2'))
  | KNormal.Var(x) -> Prog([], Var(x))
  | KNormal.App(x, ys) ->
      if S.mem x known then
	Prog([], DApp(L(Syntax.ppI x), ys))
d167 7
a173 4
	Prog([], App(x, ys))
  | KNormal.NegInt(x) -> Prog([], NegInt(g x))
  | KNormal.SubInt(x, y) -> Prog([], SubInt(x, g y))
  | KNormal.Imm(m) -> Prog([], Imm(m))
@


1.4
log
@going to use a global variable
@
text
@d1 2
d79 1
a79 1
  | Let(x, e1, e2) -> FinSet.union (fv e1) (FinSet.remove x (fv e2))
d84 3
a86 3
	    (FinSet.add x xs,
	     FinSet.union yzs (FinSet.from_list (y :: zs))))
	  (FinSet.empty, FinSet.empty)
d88 9
a96 9
      FinSet.diff (FinSet.union yzs (fv e)) xs
  | Var(x) -> FinSet.from_list [x]
  | Label(_) -> FinSet.empty
  | App(x, ys) -> FinSet.from_list (x :: ys)
  | DApp(_, ys) -> FinSet.from_list ys
  | NegInt(Ident(x)) -> FinSet.from_list [x]
  | NegInt(SInt(_)) -> FinSet.empty
  | SubInt(x, Ident(y)) -> FinSet.from_list [x; y]
  | SubInt(x, SInt(_)) -> FinSet.from_list [x]
d98 1
a98 1
      FinSet.add x (FinSet.add y (FinSet.union (fv e1) (fv e2)))
d100 2
a101 2
      FinSet.add x (FinSet.union (fv e1) (fv e2))
  | Imm(_) -> FinSet.empty
d116 3
a118 3
	if FinSet.diff free known = FinSet.empty then
	  FinSet.union known
	    (FinSet.from_list
d129 3
a131 3
	    let zs = FinSet.to_list (FinSet.diff
				       (fv e1')
				       (FinSet.from_list ys)) in
d145 1
a145 1
      let used = List.exists (fun (x, _) -> FinSet.mem x (fv e2')) bindings in
d162 1
a162 1
      if FinSet.mem x known then
@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
let ppL (L(l)) = ".L" ^ l
d35 40
d105 1
a105 1
let rec f = function
d107 2
a108 2
      let Prog(fundefs1, e1') = f e1 in
      let Prog(fundefs2, e2') = f e2 in
d111 10
d126 1
a126 1
	    let Prog(fundefs1, e1') = f e1 in
d142 2
a143 1
      let Prog(fundefs2, e2') = f e2 in
d145 9
a153 4
	   List.fold_right
	     (fun (x', l) e -> Let(x', Label(l), e))
	     env
	     (LetRec(bindings, e2')))
d155 2
a156 2
      let Prog(fundefs1, e1') = f e1 in
      let Prog(fundefs2, e2') = f e2 in
d159 5
a163 1
  | KNormal.App(x, ys) -> Prog([], App(x, ys))
@


1.2
log
@going to remember fv
@
text
@d6 3
d12 1
a12 1
  | IfLEInt of 'a * 'a * 'a t * 'a t
d16 3
a18 2
  | NegInt of 'a
  | SubInt of 'a * 'a
d26 10
d50 6
a55 3
  | NegInt(x) -> FinSet.from_list [x]
  | SubInt(x, y) -> FinSet.from_list [x; y]
  | IfLEInt(x, y, e1, e2) ->
d57 2
d61 4
d80 1
a80 1
	    let l = L(Syntax.ppI(x)) in
d101 1
a101 1
      Prog(fundefs1 @@ fundefs2, IfLEInt(x, y, e1', e2'))
d104 2
a105 2
  | KNormal.NegInt(x) -> Prog([], NegInt(x))
  | KNormal.SubInt(x, y) -> Prog([], SubInt(x, y))
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
  | Let of 'a * 'a exp * 'a t
d9 1
a9 2
  | Return of 'a exp
and 'a exp =
a14 1
  | IfLEInt of 'a * 'a * 'a t * 'a t
d23 1
a23 1
  | Let(x, e1, e2) -> FinSet.union (fv' e1) (FinSet.remove x (fv e2))
a32 2
  | Return(e) -> fv' e
and fv' = function
d43 2
a44 2
  | ANormal.Let(x, e1, e2) ->
      let (fundefs1, e1') = f' e1 in
d47 1
a47 1
  | ANormal.LetRec(fundefs, e2) ->
d50 3
a52 3
	  (fun { ANormal.name = x; 
		 ANormal.args = ys;
		 ANormal.body = e1 } (fundefs1s, bindings, env) ->
d75 1
a75 5
  | ANormal.Return(e) ->
      let (fundefs, e') = f' e in
      Prog(fundefs, Return(e'))
and f' = function
  | ANormal.IfLEInt(x, y, e1, e2) ->
d78 6
a83 6
      (fundefs1 @@ fundefs2, IfLEInt(x, y, e1', e2'))
  | ANormal.Var(x) -> ([], Var(x))
  | ANormal.App(x, ys) -> ([], App(x, ys))
  | ANormal.NegInt(x) -> ([], NegInt(x))
  | ANormal.SubInt(x, y) -> ([], SubInt(x, y))
  | ANormal.Imm(m) -> ([], Imm(m))
@
