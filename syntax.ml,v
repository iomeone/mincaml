head	1.3;
access;
symbols;
locks
	sumii:1.3; strict;
comment	@; @;


1.3
date	2002.12.09.12.18.57;	author sumii;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.03.00.09.03;	author sumii;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.03.00.27.56;	author sumii;	state Exp;
branches;
next	;


desc
@@


1.3
log
@*** empty log message ***
@
text
@type ident = string

module M = FinMap.Make (struct type t = ident end)
module S = FinSet.Make (struct type t = ident end)

let gentyp x = (x, Type.Var(ref None))

type t =
  | Var of ident
  | NegInt of t
  | SubInt of t * t
  | AddInt of t * t
  | IfEqInt of t * t * t * t
  | IfLEInt of t * t * t * t
  | Tuple of t list
  | LetTuple of (ident * Type.t) list * t * t
  | Put of t * t * t
  | Get of t * t
  | Let of (ident * Type.t) * t * t
  | LetRec of fundef list (* mutual recursion *) * t
  | App of t * t list
  | Array of t * t
  | Int of int
  | Float of float
  | Unit
and fundef = { name : ident * Type.t;
	       args : (ident * Type.t) list;
	       body : t }

let rec fv = function
  | Let(x, e1, e2) -> S.union (fv e1) (S.remove (fst x) (fv e2))
  | LetRec(fundefs, e2) ->
      let (xs, zs) =
	List.fold_left
	  (fun (xs, zs) { name = x; args = ys; body = e1 } ->
	    (S.add (fst x) xs,
	     S.union zs (S.diff (fv e1) (S.of_list (List.map fst ys)))))
	  (S.empty, S.empty)
	  fundefs in
      S.diff (S.union zs (fv e2)) xs
  | Var(x) -> S.of_list [x]
  | App(e1, e2s) -> S.union (fv e1) (S.unions (List.map fv e2s))
  | Array(e1, e2) -> S.union (fv e1) (fv e2)
  | NegInt(e) -> fv e
  | AddInt(e1, e2) -> S.union (fv e1) (fv e2)
  | SubInt(e1, e2) -> S.union (fv e1) (fv e2)
  | IfEqInt(e1, e2, e3, e4) ->
      S.union (fv e1) (S.union (fv e2) (S.union (fv e3) (fv e4)))
  | IfLEInt(e1, e2, e3, e4) ->
      S.union (fv e1) (S.union (fv e2) (S.union (fv e3) (fv e4)))
  | Tuple(es) -> S.unions (List.map fv es)
  | LetTuple(xs, e1, e2) ->
      S.union (fv e1) (S.diff (fv e2) (S.of_list (List.map fst xs)))
  | Put(e1, e2, e3) -> S.union (fv e1) (S.union (fv e2) (fv e3))
  | Get(e1, e2) -> S.union (fv e1) (fv e2)
  | Int(_) -> S.empty
  | Float(_) -> S.empty
  | Unit -> S.empty
@


1.2
log
@*** empty log message ***
@
text
@d6 1
a6 1
let gentyp x = (x, Type.TVar(ref None))
d16 1
a16 1
  | LetTuple of (ident * Type.typ) list * t * t
d19 1
a19 1
  | Let of (ident * Type.typ) * t * t
d22 1
d26 2
a27 2
and fundef = { name : ident * Type.typ;
	       args : (ident * Type.typ) list;
d38 2
a39 1
	  (S.empty, S.empty) fundefs in
d43 1
@


1.1
log
@Initial revision
@
text
@d1 6
a6 10
type ident = I of string
let ppI (I(x)) = x
(*
  let s = String.copy x in
  for i = 0 to String.length s - 1 do
    if String.get s i = '.' then
      String.set s i '_'
  done;
  s
*)
d16 2
a17 2
  | LetTuple of ident list * t * t
  | Put of t * t * t * t (* continuation *)
d19 2
a20 2
  | Let of ident * t * t
  | LetRec of fundef list (* mutually recursive functions *) * t
d24 32
a55 1
and fundef = { name : ident; args : ident list; body : t }
@
