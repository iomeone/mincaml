head	1.7;
access;
symbols;
locks
	sumii:1.7; strict;
comment	@; @;


1.7
date	2005.01.29.01.20.05;	author sumii;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.28.01.24.27;	author sumii;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.14.09.47.46;	author sumii;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.05.09.04.31;	author sumii;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.17.08.24.04;	author sumii;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.06.08.24.09;	author sumii;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.03.14.36.57;	author sumii;	state Exp;
branches;
next	;


desc
@@


1.7
log
@*** empty log message ***
@
text
@(* translation into SPARC assembly with infinite number of virtual registers *)

open SparcAsm

let data = ref []
let labenv = ref M.empty

let classify xts ini addf addi =
  List.fold_left
    (fun acc (x, t) ->
      match t with
      | Type.Unit -> acc
      | Type.Float -> addf acc x
      | _ -> addi acc x)
    ini
    xts

let separate xts =
  classify
    xts
    ([], [])
    (fun (int, float) x -> (int, float @@ [x]))
    (fun (int, float) x -> (int @@ [x], float))

let align xts ini addf addi =
  classify
    xts
    ini
    (fun (offset, acc) x ->
      let offset = (offset + 4) / 8 * 8 in
      (offset + 8, addf x offset acc))
    (fun (offset, acc) x ->
      (offset + 4, addi x offset acc))

let rec g env = function
  | Closure.Unit -> Ans(Nop)
  | Closure.Int(i) -> Ans(Set(i))
  | Closure.Float(d) ->
      let x = Id.genid "l" in
      data := (Id.L(x), d) :: !data;
      Let(x, SetL(Id.L(x)), Ans(LdDF(x, C(0))))
  | Closure.Neg(x) -> Ans(Neg(x))
  | Closure.Add(x, y) -> Ans(Add(x, V(y)))
  | Closure.Sub(x, y) -> Ans(Sub(x, V(y)))
  | Closure.FNeg(x) -> Ans(FNegD(x))
  | Closure.FAdd(x, y) -> Ans(FAddD(x, y))
  | Closure.FSub(x, y) -> Ans(FSubD(x, y))
  | Closure.FMul(x, y) -> Ans(FMulD(x, y))
  | Closure.FDiv(x, y) -> Ans(FDivD(x, y))
  | Closure.IfEq(x, y, e1, e2) ->
      (match M.find x env with
      | Type.Int -> Seq(Cmp(x, V(y)), Ans(IfEq(g env e1, g env e2)))
      | _ -> failwith "equality supported only for int")
  | Closure.IfLE(x, y, e1, e2) ->
      (match M.find x env with
      | Type.Int -> Seq(Cmp(x, V(y)), Ans(IfLE(g env e1, g env e2)))
      | Type.Float -> Seq(FCmpD(x, y), Ans(IfFLE(g env e1, g env e2)))
      | _ -> failwith "inequality supported only for int and float")
  | Closure.Let((x, t1), e1, e2) ->
      let e1' = g env e1 in
      let e2' = g (M.add x t1 env) e2 in
      concat e1' (x, t1) e2'
  | Closure.Var(x) ->
      (match M.find x env with
      | Type.Unit -> Ans(Nop)
      | Type.Float -> Ans(FMovD(x))
      | _ -> Ans(Mov(x)))
  | Closure.MakeCls(bindings, e2) ->
      (* Closureのアドレスをセットしてから、自由変数の値をストア *)
      let (set_addr, store_fv) = (* コードを挿入する関数たち *)
	List.fold_left
	  (fun (set_addr, store_fv) ->
	    fun ((x, t), { Closure.entry = l; Closure.actual_fv = ys }) ->
	      let (offset, store_fv) =
		align
		  (List.map (fun y -> (y, M.find y env)) ys)
		  (4, store_fv)
		  (fun y offset store_fv ->
		    fun e0 -> store_fv (Seq(StDF(y, x, C(offset)), e0)))
		  (fun y offset store_fv ->
		    fun e0 -> store_fv (Seq(St(y, x, C(offset)), e0))) in
	      ((fun e0 ->
		set_addr
		  (Let(x, Mov(reg_hp),
		       Let(reg_hp, Add(reg_hp, C(offset)),
			   e0)))),
	       let z = Id.genid "l" in
	       (fun e0 ->
		 Let(z, SetL(l),
		     Seq(St(z, x, C(0)),
			 store_fv e0)))))
	  ((fun e0 -> e0), (fun e0 -> e0))
	  bindings in
      set_addr (store_fv (g (M.add_list (List.map fst bindings) env) e2))
  | Closure.AppCls(x, ys) ->
      let (int, float) = separate (List.map (fun y -> (y, M.find y env)) ys) in
      (match M.find x env with
      | Type.Fun(_, Type.Unit) -> Ans(CallCls(x, int, float))
      | Type.Fun(_, Type.Float) -> FLetD(fregs.(0), CallCls(x, int, float), Ans(FMovD(fregs.(0))))
      | Type.Fun(_, _) -> Let(regs.(0), CallCls(x, int, float), Ans(Mov(regs.(0))))
      | _ -> assert false)
  | Closure.AppDir(Id.L(x), ys) ->
      let (int, float) = separate (List.map (fun y -> (y, M.find y env)) ys) in
      (match M.find x !labenv with
      | Type.Fun(_, Type.Unit) -> Ans(CallDir(Id.L(x), int, float))
      | Type.Fun(_, Type.Float) -> FLetD(fregs.(0), CallDir(Id.L(x), int, float), Ans(FMovD(fregs.(0))))
      | Type.Fun(_, _) -> Let(regs.(0), CallDir(Id.L(x), int, float), Ans(Mov(regs.(0))))
      | _ -> assert false)
  | Closure.Tuple(xs) ->
      let y = Id.genid "t" in
      let (offset, store) = (* コードを挿入する関数 *)
	align
	  (List.map (fun x -> (x, M.find x env)) xs)
	  (0, (fun e0 -> e0))
	  (fun x offset store ->
	    fun e0 -> store (Seq(StDF(x, y, C(offset)), e0)))
	  (fun x offset store ->
	    fun e0 -> store (Seq(St(x, y, C(offset)), e0))) in
      Let(y, Mov(reg_hp),
	  Let(reg_hp, Add(reg_hp, C(offset)),
	      store (Ans(Mov(y)))))
  | Closure.LetTuple(xts, y, e2) ->
      let (offset, load) = (* コードを挿入する関数 *)
	align
	  xts
	  (0, (fun e0 -> e0))
	  (fun x offset load ->
	    fun e0 -> load (Let(x, LdDF(y, C(offset)), e0)))
	  (fun x offset load ->
	    fun e0 -> load (Let(x, Ld(y, C(offset)), e0))) in
      load (g (M.add_list xts env) e2)
  | Closure.Get(x, y) ->
      let offset = Id.genid "o" in
      (match M.find x env with
      | Type.Array(Type.Unit) -> Ans(Nop)
      | Type.Array(Type.Float) -> Let(offset, SLL(y, C(3)), Ans(LdDF(x, V(offset))))
      | Type.Array(_) -> Let(offset, SLL(y, C(2)), Ans(Ld(x, V(offset))))
      | _ -> assert false)
  | Closure.Put(x, y, z) ->
      let offset = Id.genid "o" in
      (match M.find z env with
      | Type.Array(Type.Unit) -> Ans(Nop)
      | Type.Array(Type.Float) -> Let(offset, SLL(y, C(3)), Ans(StDF(z, x, V(offset))))
      | Type.Array(_) -> Let(offset, SLL(y, C(2)), Ans(St(z, x, V(offset))))
      | _ -> assert false)
  | Closure.ExtArray(l) -> Ans(SetL(l))

let h { Closure.name = (l, t); Closure.args = xts; Closure.formal_fv = yts; Closure.body = e } =
  let (int, float) = separate xts in
  { name = l;
    args = int;
    fargs = float;
    body =
      (let (offset, load) = (* コードを挿入する関数 *)
	align
	  yts
	  (4, (fun e0 -> e0))
	  (fun y offset load ->
	    fun e0 -> load (Let(y, LdDF(reg_cl, C(offset)), e0)))
	  (fun y offset load ->
	    fun e0 -> load (Let(y, Ld(reg_cl, C(offset)), e0))) in
      load (g (M.add_list xts (M.add_list yts M.empty)) e));
    ret =
      (match t with
      | Type.Fun(_, Type.Unit) -> Id.gentmp Type.Unit
      | Type.Fun(_, Type.Float) -> fregs.(0)
      | Type.Fun(_, t2) -> regs.(0)
      | _ -> assert false) }

let f (Closure.Prog(fundefs, e)) =
  data := [];
  labenv := !Typing.extenv;
  List.iter
    (fun { Closure.name = (Id.L(x), t) } ->
      labenv := M.add x t !labenv)
    fundefs;
  let fundefs = List.map h fundefs in
  let e = g M.empty e in
  Prog(!data, fundefs, e)
@


1.6
log
@*** empty log message ***
@
text
@d8 1
a8 1
let sep_float xts ini addf addi =
d18 11
a28 2
let align_float xts ini addf addi =
  sep_float xts ini
d70 1
a70 1
      let (set_addr, store_fv) =
d75 1
a75 1
		align_float
d78 9
a86 5
		  (fun y offset store_fv -> Seq(StDF(y, x, C(offset)), store_fv))
		  (fun y offset store_fv -> Seq(St(y, x, C(offset)), store_fv)) in
	      (Let(x, Mov(reg_hp),
		   Let(reg_hp, Add(reg_hp, C(offset)),
		       set_addr)),
d88 5
a92 4
	       Let(z, SetL(l),
		   Seq(St(z, x, C(0)),
		       store_fv))))
	  (Ans(Nop), Ans(Nop)) (* concatの「のりしろ」となるNop *)
d94 1
a94 3
      concat set_addr (Id.gentmp Type.Unit, Type.Unit)
	(concat store_fv (Id.gentmp Type.Unit, Type.Unit)
	   (g (M.add_list (List.map fst bindings) env) e2))
d96 6
a101 12
      let (int, float) =
	sep_float
	  (List.map (fun y -> (y, M.find y env)) ys)
	  ([], [])
	  (fun (int, float) y -> (int, float @@ [y]))
	  (fun (int, float) y -> (int @@ [y], float)) in
      Seq(CallCls(x, int, float),
	  Ans(match M.find x env with
	  | Type.Fun(_, Type.Unit) -> Nop
	  | Type.Fun(_, Type.Float) -> FMovD(fregs.(0))
	  | Type.Fun(_, _) -> Mov(regs.(1))
	  | _ -> assert false))
d103 6
a108 12
      let (int, float) =
	sep_float
	  (List.map (fun y -> (y, M.find y env)) ys)
	  ([], [])
	  (fun (int, float) y -> (int, float @@ [y]))
	  (fun (int, float) y -> (int @@ [y], float)) in
      Seq(CallDir(Id.L(x), int, float),
	  Ans(match M.find x !labenv with
	  | Type.Fun(_, Type.Unit) -> Nop
	  | Type.Fun(_, Type.Float) -> FMovD(fregs.(0))
	  | Type.Fun(_, _) -> Mov(regs.(1))
	  | _ -> assert false))
d111 2
a112 2
      let (offset, store) =
	align_float
d114 5
a118 3
	  (0, Ans(Nop)) (* のりしろ *)
	  (fun x offset store -> Seq(StDF(x, y, C(offset)), store))
	  (fun x offset store -> Seq(St(x, y, C(offset)), store)) in
d121 1
a121 2
	      concat store (Id.gentmp Type.Unit, Type.Unit)
		(Ans(Mov(y)))))
d123 9
a131 6
      let (offset, load) =
	align_float xts (0, Ans(Nop)) (* のりしろ *)
	  (fun x offset load -> Let(x, LdDF(y, C(offset)), load))
	  (fun x offset load -> Let(x, Ld(y, C(offset)), load)) in
      concat load (Id.gentmp Type.Unit, Type.Unit)
	(g (M.add_list xts env) e2)
d149 1
d151 2
d154 15
a168 20
      let (i, d, mov) =
	sep_float xts (1, 0, Ans(Nop)) (* のりしろ *)
	  (fun (i, d, mov) x -> (i, d + 1, FLetD(x, FMovD(fregs.(d)), mov)))
	  (fun (i, d, mov) x -> (i + 1, d, Let(x, Mov(regs.(i)), mov))) in
      let (offset, load) =
	align_float yts (4, Ans(Nop)) (* のりしろ *)
	  (fun y offset load -> Let(y, LdDF(regs.(0), C(offset)), load))
	  (fun y offset load -> Let(y, Ld(regs.(0), C(offset)), load)) in
      let e' = g (M.add_list xts (M.add_list yts M.empty)) e in
      concat mov (Id.gentmp Type.Unit, Type.Unit)
	(concat load (Id.gentmp Type.Unit, Type.Unit)
	   (match t with
	   | Type.Fun(_, Type.Unit) -> e'
	   | Type.Fun(_, Type.Float) ->
	       concat e' (fregs.(0), Type.Float)
		 (Ans(FMovD(fregs.(0))))
	   | Type.Fun(_, t2) ->
	       concat e' (regs.(1), t2)
		 (Ans(Mov(fregs.(1))))
	   | _ -> assert false)) }
@


1.5
log
@*** empty log message ***
@
text
@d1 1
a1 2
(* expand load/store operations and multi-word variables *)
(* tail-call optimization *)
d3 1
a3 1
open Asm
d5 2
a6 2
let high x = "H" ^ x
let low x = "L" ^ x
d8 159
a166 134
let expand = function
  | (x, Type.Unit) -> []
  | (x, Type.Float) -> [high x; low x]
  | (x, _) -> [x] (* [X] error-prone *)

let expands xs =
  List.fold_right
    (fun x acc -> expand x @@ acc)
    xs
    []

type cont = (* ident option * Type.t *)
  | Cont of Closure.ident (* ident * Type.t *)
  | Tail of Type.t (* unit * Type.t *)

let g' = function KNormal.V(x) -> V(fst x) | KNormal.C(i) -> C(i)
let rec g = function
  | k, Closure.Global(l) ->
      let y = gentmp "p" in
      Label(fst l, y) :: g (k, Closure.Var(y, snd l))
  | k, Closure.IfEqInt(x, y, e1, e2) ->
      [IfEq(fst x, g' y, g (k, e1), g (k, e2))]
  | k, Closure.IfLEInt(x, y, e1, e2) ->
      [IfLE(fst x, g' y, g (k, e1), g (k, e2))]
  | k, Closure.Let(x, e1, e2) -> g (Cont(x), e1) @@ g (k, e2)
  | k, Closure.LetTuple(xs, y, e) ->
      let y' = fst y in
      let used = Closure.fv e in
      snd (List.fold_left
	     (fun (offset, e) dst ->
	       (offset + 4,
		if Closure.S.for_all (* [XX] dirty and inefficient *)
		    (fun (z, _) ->
		      dst <> z && dst <> high z && dst <> low z)
		    used then e else
		Load(y', offset, dst) :: e))
	     (0, [])
	     (expands xs)) @@
      g (k, e)
  | k, Closure.MakeCls(bindings, e) ->
      List.fold_left
	(fun e (f, { Closure.actual_fv = xs }) ->
	  let xs' = expands xs in
	  Mov("HP", fst f) ::
	  Add("HP", C(4 * (1 + List.length xs')), "HP") ::
	  e)
	[]
	bindings @@
      List.fold_left
	(fun e (f, {Closure.entry = l; Closure.actual_fv = xs }) ->
	  let f' = fst f in
	  let y = gentmp "l" in
	  Label(fst l, y) :: Store(y, f', 0) ::
	  snd (List.fold_left
		 (fun (offset, e) x -> (offset + 4, Store(x, f', offset) :: e))
		 (4, [])
		 (expands xs)))
	[]
	bindings @@
      g (k, e)
  | Tail(_), Closure.Var(x) -> [Ret("HP" :: expand x, "RA")]
  | Tail(_), Closure.AppCls(x, ys) ->
      [TailCallCls(fst x, "HP" :: expands ys, "RA")]
  | Tail(_), Closure.AppDir(l, xs) ->
      [TailCallDir(fst l, "HP" :: expands xs, "RA")]
  | Tail(t), e -> (* [X] error-prone *)
      let k = KNormal.gentmp "r" t in
      g (Cont(k), e) @@ [Ret("HP" :: expand k, "RA")]
  | Cont(k), Closure.Var(x) ->
      List.fold_left2
	(fun e src dst -> Mov(src, dst) :: e)
	[]
	(expand x)
	(expand k)
  | Cont(k), Closure.NegInt(x) -> [Neg(fst x, fst k)]
  | Cont(k), Closure.AddInt(x, y) -> [Add(fst x, g' y, fst k)]
  | Cont(k), Closure.SubInt(x, y) -> [Sub(fst x, g' y, fst k)]
  | Cont(k), Closure.Tuple(xs) ->
      let xs' = expands xs in
      Mov("HP", fst k) ::
      snd (List.fold_left
	     (fun (offset, e) src ->
	       (offset + 4, Store(src, fst k, offset) :: e))
	     (0, [])
	     xs') @@
      [Add("HP", C(4 * List.length xs'), "HP")]
  | Cont(_), Closure.Put(x, KNormal.C(i), z) ->
      let z' = expand z in
      let offset = i lsl Type.size (snd z) in
      snd (List.fold_left
	     (fun (offset, e) src ->
	       (offset + 4, Store(src, fst x, offset) :: e))
	     (offset, [])
	     z')
  | Cont(_), Closure.Put(x, KNormal.V(y), z) ->
      let z' = expand z in
      let i = gentmp "i" in
      let p = gentmp "p" in
      Shift(fst y, Type.size (snd z), i) :: Add(fst x, V(i), p) ::
      snd (List.fold_left
	     (fun (offset, e) src -> (offset + 4, Store(src, p, offset) :: e))
	     (0, [])
	     z')
  | Cont(k), Closure.Get(x, KNormal.C(i)) ->
      let dest' = expand k in
      let offset = i lsl Type.size (snd k) in
      snd (List.fold_left
	     (fun (offset, e) dst ->
	       (offset + 4, Load(fst x, offset, dst) :: e))
	     (offset, [])
	     dest')
  | Cont(k), Closure.Get(x, KNormal.V(y)) ->
      let dest' = expand k in
      let i = gentmp "i" in
      let p = gentmp "p" in
      Shift(fst y, Type.size (snd k), i) :: Add(fst x, V(i), p) ::
      snd (List.fold_left
	     (fun (offset, e) dst -> (offset + 4, Load(p, offset, dst) :: e))
	     (0, [])
	     dest')
  | Cont(k), Closure.AppCls(x, ys) ->
      [CallCls(fst x, "HP" :: expands ys, "HP" :: expand k)]
  | Cont(k), Closure.AppDir(l, xs) ->
      [CallDir(fst l, "HP" :: expands xs, "HP" :: expand k)]
  | Cont(k), Closure.Int(i) -> [Int(i, fst k)]
  | Cont(k), Closure.Float(d) ->
      [FloatHigh(d, high (fst k)); FloatLow(d, low (fst k))]
  | Cont(_), Closure.Unit -> []

let h { Closure.name = l; Closure.args = xs;
	Closure.formal_fv = ys; Closure.body = e } =
  let t = snd (Type.dom_codom (snd l)) in
  { name = fst l; args = "HP" :: expands xs;
    formal_fv = expands ys; body = g (Tail(t), e) }
d169 9
a177 1
  Prog(List.map h fundefs, g (Cont("ANS", Type.Unit), e))
@


1.4
log
@going to remove TailCallCls and TailCallDir
@
text
@d12 1
a12 1
  | (x, _) -> [x] (* [XXX] error-prone *)
d40 1
a40 1
		if Closure.S.for_all (* [XXX] dirty and inefficient *)
d69 1
a69 1
  | Tail(_), Closure.Var(x) -> [Ret("RA", "HP" :: expand x)]
d71 1
a71 1
      [TailCallCls(fst x, "HP" :: expands ys)]
d73 2
a74 2
      [TailCallDir(fst l, "HP" :: expands xs)]
  | Tail(t), e -> (* [XXX] error-prone *)
d76 1
a76 1
      g (Cont(k), e) @@ [Ret("RA", "HP" :: expand k)]
d91 1
a91 1
	       (offset + 4, Store(src, "HP", offset) :: e))
d145 1
a145 1
  Prog(List.map h fundefs, g (Tail(Type.Int), e))
@


1.3
log
@*** empty log message ***
@
text
@d6 2
a7 2
let high (Syntax.I(x)) = Syntax.I("H_" ^ x)
let low (Syntax.I(x)) = Syntax.I("L_" ^ x)
d10 3
a12 3
  | (x, Type.TUnit) -> []
  | (x, Type.TFloat) -> [high x; low x]
  | (x, _) -> [x]
d20 15
a34 25
let rec g target = function
  | Closure.Var(x) ->
      List.fold_left2
	(fun e src dst -> Mov(src, dst) :: e)
	[]
	(expand x)
	(expand target)
  | Closure.NegInt(x) -> [Neg(fst x, fst target)]
  | Closure.AddInt(x, y) -> [Add(fst x, fst y, fst target)]
  | Closure.SubInt(x, y) -> [Sub(fst x, fst y, fst target)]
  | Closure.AddConst(x, i) -> [AddConst(fst x, i, fst target)]
  | Closure.IfEqInt(x, y, e1, e2) ->
      [IfEq(fst x, fst y, g target e1, g target e2)]
  | Closure.IfLEInt(x, y, e1, e2) ->
      [IfLE(fst x, fst y, g target e1, g target e2)]
  | Closure.Tuple(xs) ->
      let xs' = expands xs in
      Mov(reg_hp, fst target) ::
      snd (List.fold_left
	     (fun (offset, e) src ->
	       (offset + 4, Store(src, reg_hp, offset) :: e))
	     (0, [])
	     xs') @@
      [AddConst(reg_hp, 4 * List.length xs', reg_hp)]
  | Closure.LetTuple(xs, y, e) ->
d47 2
a48 27
      g target e
  | Closure.Put(x, y, z) ->
      let z' = expand z in
      let size = List.length z' in
      let i = gentmp "i" in
      let p = gentmp "p" in
      Shift(fst y, 1 + size, i) ::
      Add(fst x, i, p) ::
      snd (List.fold_left
	     (fun (offset, e) src ->
	       (offset + 4, Store(src, p, offset) :: e))
	     (0, [])
	     z')
  | Closure.Get(x, y) ->
      let target' = expand target in
      let size = List.length target' in
      let i = gentmp "i" in
      let p = gentmp "p" in
      Shift(fst y, 1 + size, i) ::
      Add(fst x, i, p) ::
      snd (List.fold_left
	     (fun (offset, e) dst ->
	       (offset + 4, Load(p, offset, dst) :: e))
	     (0, [])
	     target')
  | Closure.Let(x, e1, e2) -> g x e1 @@ g target e2
  | Closure.MakeCls(bindings, e) ->
d52 2
a53 2
	  Mov(reg_hp, fst f) ::
	  AddConst(reg_hp, 4 + List.length xs', reg_hp) ::
d68 69
a136 7
      g target e
  | Closure.AppCls(x, ys) -> [CallCls(fst x, expands ys, expand target)]
  | Closure.AppDir(l, xs) -> [CallDir(fst l, expands xs, expand target)]
  | Closure.Int(i) -> [Int(i, fst target)]
  | Closure.Float(d) -> [FloatHigh(d, high (fst target));
			 FloatLow(d, low (fst target))]
  | Closure.Unit -> []
d140 3
a142 9
  let target = (Syntax.I("R"), snd (Type.dom_codom (snd l))) in
(*
    match snd (Type.dom_codom (snd l)) with
    | Type.TUnit -> []
    | Type.TFloat -> [reg 1; reg 2]
    | _ -> [reg 1]
*)
  { name = fst l; args = expands xs;
    formal_fv = expands ys; body = g target e (* @@ [Ret(target)] *) }
d145 1
a145 2
  let target = (Syntax.I("R"), Type.TInt) in
  Prog(List.map h fundefs, g target e (* @@ [Ret(target)] *) )
@


1.2
log
@going to make "call" a primitive
@
text
@d1 2
a2 1
(* assembly code with virtual registers *)
d26 5
a30 5
	target
  | Closure.NegInt(x) -> [Neg(fst x, List.hd target)]
  | Closure.AddInt(x, y) -> [Add(fst x, fst y, List.hd target)]
  | Closure.SubInt(x, y) -> [Sub(fst x, fst y, List.hd target)]
  | Closure.AddConst(x, i) -> [AddConst(fst x, i, List.hd target)]
d37 1
a37 1
      Mov(reg_hp, List.hd target) ::
d51 2
a52 3
		    (fun z ->
		      let z' = fst z in
		      dst <> z' && dst <> high z' && dst <> low z')
d71 2
a72 1
      let size = List.length target in
d81 2
a82 2
	     target)
  | Closure.Let(x, e1, e2) -> g (expand x) e1 @@ g target e2
d104 5
a108 18
  | Closure.AppCls(x, ys) ->
      let x' = fst x in
      Mov(x', reg 0) ::
      snd (List.fold_left
	     (fun (i, e) y -> (i + 1, Mov(y, reg i) :: e)) (* [XXX] spill *)
	     (1, [])
	     (expands ys)) @@
      let z = gentmp "l" in
      [Load(x', 0, z); Call(z)]
  | Closure.AppDir(l, xs) ->
      snd (List.fold_left
	     (fun (i, e) x -> (i + 1, Mov(x, reg i) :: e)) (* [XXX] spill *)
	     (1, [])
	     (expands xs)) @@
      [CallLab(fst l)]
  | Closure.Int(i) -> [Int(i, List.hd target)]
  | Closure.Float(d) -> [FloatHigh(d, List.nth target 0);
			 FloatLow(d, List.nth target 1)]
d113 2
a114 1
  let target =
d118 8
a125 14
    | _ -> [reg 1] in
  let e' =
    snd (List.fold_left
	   (fun (i, e) x -> (i + 1, Mov(reg i, x) :: e)) (* [XXX] spill *)
	   (1, [])
	   (expands xs)) @@
    snd (List.fold_left
	   (fun (offset, e) y -> (offset + 4, Load(reg 0, offset, y) :: e))
	   (4, [])
	   (expands ys)) @@
    g target e in
  { name = fst l; body = e' }

let f (Closure.Prog(fundefs, e)) = Prog(List.map h fundefs, g [reg 1] e)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
(* virtual machine code *)
d3 1
a3 43
open Type
open Register

type ident = Syntax.ident
type label = Closure.lab
type closure = { entry : label; actual_fv : ident list }
type t =
  | Mov of ident * ident * t
  | Load of ident * int * ident * t
  | Store of ident * ident * int * t
  | Neg of ident * ident * t
  | Add of ident * ident * ident * t
  | Sub of ident * ident * ident * t
  | AddConst of ident * int * ident * t
  | IfEq of ident * ident * t * t
  | IfLE of ident * ident * t * t
  | Int of int * ident * t
  | Float of float * ident * t
  | Ret
type fundef = { name : label;
		args : ident list;
		formal_fv : ident list;
		body : t }
type prog = Prog of fundef list * t

module M = Syntax.M
module S = Syntax.S

let rec fv = function
  | Mov(x, y, e) -> S.add x (S.remove y (fv e))
  | Load(x, _, y, e) -> S.add x (S.remove y (fv e))
  | Store(x, y, _, e) -> S.add x (S.add y (fv e))
  | Neg(x, y, e) -> S.add x (S.remove y (fv e))
  | Add(x, y, z, e) -> S.add x (S.add y (S.remove z (fv e)))
  | Sub(x, y, z, e) -> S.add x (S.add y (S.remove z (fv e)))
  | AddConst(x, _, y, e) -> S.add x (S.remove y (fv e))
  | IfEq(x, y, e1, e2) -> S.add x (S.add y (S.union (fv e1) (fv e2)))
  | IfLE(x, y, e1, e2) -> S.add x (S.add y (S.union (fv e1) (fv e2)))
  | Int(_, x, e) -> S.remove x (fv e)
  | Float(_, x, e) -> S.remove x (fv e)
  | Ret -> S.empty

let gentmp x = Syntax.I(Fresh.gensym ("T_" ^ x))
a20 1
      let x' = expand x in
d22 3
a24 3
	(fun e src dst -> Mov(src, dst, e))
	Ret
	x'
d26 4
a29 3
  | Closure.NegInt(x) -> Neg(fst x, List.hd target, Ret)
  | Closure.AddInt(x, y) -> Add(fst x, fst y, List.hd target, Ret)
  | Closure.SubInt(x, y) -> Sub(fst x, fst y, List.hd target, Ret)
d31 1
a31 1
      IfEq(fst x, fst y, g target e1, g target e2)
d33 1
a33 1
      IfLE(fst x, fst y, g target e1, g target e2)
d36 7
a42 6
      Mov(reg_hp, List.hd target,
	  snd (List.fold_left
		 (fun (offset, e) src ->
		   (offset + 4, Store(src, reg_hp, offset, e)))
		 (0, AddConst(reg_hp, 4 * List.length xs', reg_hp, Ret))
		 xs'))
a43 1
      let xs' = expands xs in
d45 1
a45 2
      let e' = g target e in
      let used = fv e' in
d49 9
a57 5
		if S.mem dst used then
		  Load(y', offset, dst, e)
		else e))
	     (0, e')
	     xs')
d60 22
a81 14
      (match List.length z' with
      | 0 -> Ret
      |	1 ->
	  let p = gentmp "p" in
	  Add(y, y, p,
	      let q = gentmp "q" in
	      Add(p, p, q,
		  let r = gentmp "r" in
		  Add(x, q, r,
		      Load(r, 0, z, Ret))))
      |	2 -> )
(*
  | Closure.Get(x, y) -> Get(fst x, fst y)
  | Closure.Let(x, e1, e2) -> Let(expand x, g e2, g e2)
d83 39
a121 15
      MakeCls(List.fold_left
		(fun acc
		    (f, { Closure.entry = l;
			  Closure.actual_fv = xs }) ->
			    (fst f, { entry = fst l;
				      actual_fv = expands xs }) :: acc)
		[]
		bindings,
	      g e)
  | Closure.AppCls(x, ys) -> AppCls(fst x, expands ys)
  | Closure.AppDir(l, xs) -> AppDir(fst l, expands xs)
  | Closure.Int(i) -> Int(i)
  | Closure.Float(d) -> Float(d)
  | Closure.Unit -> Unit
*)
d123 1
a123 1
let h { Closure.name = l; Closure.args = rs;
d126 3
a128 3
    match snd (dom_codom (snd l)) with
    | TUnit -> []
    | TFloat -> [reg 1; reg 2]
d130 11
a140 2
  { name = fst l; args = expands rs;
    formal_fv = expands ys; body = g target e }
@
