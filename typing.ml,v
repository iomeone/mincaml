head	1.5;
access;
symbols;
locks
	sumii:1.5; strict;
comment	@; @;


1.5
date	2002.12.09.12.17.10;	author sumii;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.05.02.33.10;	author sumii;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.03.07.08.50;	author sumii;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.01.02.38.37;	author sumii;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.30.14.51.24;	author sumii;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@(* type inference/reconstruction *)
(* could be fused with K-normalization *)

open Syntax

exception Unify of Type.t * Type.t
exception Error of t * Type.t * Type.t

let initenv =
  ref
    (M.add "fsub" (Type.Fun([Type.Float; Type.Float], Type.Float))
    (M.add "fadd" (Type.Fun([Type.Float; Type.Float], Type.Float))
    (M.add "fmul" (Type.Fun([Type.Float; Type.Float], Type.Float))
    (M.add "fdiv" (Type.Fun([Type.Float; Type.Float], Type.Float))
    (M.add "fneg" (Type.Fun([Type.Float], Type.Float))
    (M.add "imul" (Type.Fun([Type.Int; Type.Int], Type.Int))
       M.empty))))))

(* for pretty printing (and normalization) *)
let rec deref_typ = function
  | Type.Var({ contents = None } as r) ->
      Format.eprintf "detected uninstantiated type variable; assuming int@@.";
      r := Some(Type.Int);
      Type.Int
  | Type.Var({ contents = Some(t) } as r) ->
      let t' = deref_typ t in
      r := Some(t');
      t'
  | Type.Int -> Type.Int
  | Type.Float -> Type.Float
  | Type.Unit -> Type.Unit
  | Type.Tuple(ts) -> Type.Tuple(List.map deref_typ ts)
  | Type.Array(t) -> Type.Array(deref_typ t)
  | Type.Fun(t1s, t2) -> Type.Fun(List.map deref_typ t1s, deref_typ t2)
let deref_id (x, t) = (x, deref_typ t)
let rec deref_term = function
  | Var(x) -> Var(x)
  | NegInt(e) -> NegInt(deref_term e)
  | AddInt(e1, e2) -> AddInt(deref_term e1, deref_term e2)
  | SubInt(e1, e2) -> SubInt(deref_term e1, deref_term e2)
  | IfEqInt(e1, e2, e3, e4) ->
      IfEqInt(deref_term e1, deref_term e2, deref_term e3, deref_term e4)
  | IfLEInt(e1, e2, e3, e4) ->
      IfLEInt(deref_term e1, deref_term e2, deref_term e3, deref_term e4)
  | Tuple(es) -> Tuple(List.map deref_term es)
  | LetTuple(xs, e1, e2) ->
      LetTuple(List.map deref_id xs, deref_term e1, deref_term e2)
  | Put(e1, e2, e3) ->
      Put(deref_term e1, deref_term e2, deref_term e3)
  | Get(e1, e2) -> Get(deref_term e1, deref_term e2)
  | Let(x, e1, e2) -> Let(deref_id x, deref_term e1, deref_term e2)
  | LetRec(fundefs, e2) ->
      LetRec(List.map
	       (fun { name = x; args = ys; body = e1 } ->
		 { name = deref_id x;
		   args = List.map deref_id ys;
		   body = deref_term e1 })
	       fundefs,
	     deref_term e2)
  | App(e1, e2s) -> App(deref_term e1, List.map deref_term e2s)
  | Array(e1, e2) -> Array(deref_term e1, deref_term e2)
  | Int(i) -> Int(i)
  | Float(d) -> Float(d)
  | Unit -> Unit

let rec occur r1 = function
  | Type.Var(r2) when r1 == r2 -> true
  | Type.Var({ contents = None }) -> false
  | Type.Var({ contents = Some(t2) }) -> occur r1 t2
  | Type.Tuple(t2s) -> List.exists (occur r1) t2s
  | Type.Array(t2) -> occur r1 t2
  | Type.Fun(t2s, t2') -> List.exists (occur r1) t2s || occur r1 t2'
  | _ -> false (* [XXX] error-prone *)

let rec unify t1 t2 =
  match t1, t2 with
  | Type.Var(r1), Type.Var(r2) when r1 == r2 -> ()
  | Type.Var({ contents = Some(t1') }), _ -> unify t1' t2
  | _, Type.Var({ contents = Some(t2') }) -> unify t1 t2'
  | Type.Var({ contents = None } as r1), _ ->
      if occur r1 t2 then raise (Unify(t1, t2));
      r1 := Some(t2)
  | _, Type.Var({ contents = None } as r2) ->
      if occur r2 t1 then raise (Unify(t1, t2));
      r2 := Some(t1)
  | Type.Int, Type.Int -> ()
  | Type.Float, Type.Float -> ()
  | Type.Tuple(t1s), Type.Tuple(t2s) ->
      (try List.iter2 unify t1s t2s
      with Invalid_argument("List.iter2") -> raise (Unify(t1, t2)))
  | Type.Array(t1), Type.Array(t2) -> unify t1 t2
  | Type.Fun(t1s, t1'), Type.Fun(t2s, t2') ->
      (try List.iter2 unify t1s t2s
      with Invalid_argument("List.iter2") -> raise (Unify(t1, t2)));
      unify t1' t2'
  | Type.Unit, Type.Unit -> ()
  | _, _ -> raise (Unify(t1, t2)) (* [XXX] error-prone *)

let rec g env e =
  try
    (match e with
    | Var(x) -> M.find x env
    | NegInt(e) ->
	unify Type.Int (g env e);
	Type.Int
    | (AddInt(e1, e2) | SubInt(e1, e2)) ->
	unify Type.Int (g env e1);
	unify Type.Int (g env e2);
	Type.Int
    | (IfEqInt(e1, e2, e3, e4) | IfLEInt(e1, e2, e3, e4)) ->
	unify Type.Int (g env e1);
	unify Type.Int (g env e2);
	let t3 = g env e3 in
	let t4 = g env e4 in
	unify t3 t4;
	t3
    | Tuple(es) -> Type.Tuple(List.map (g env) es)
    | LetTuple(xts, e1, e2) ->
	unify (Type.Tuple(List.map snd xts)) (g env e1);
	g (M.adds xts env) e2
    | Put(e1, e2, e3) ->
	let t = g env e3 in
	unify (Type.Array(t)) (g env e1);
	unify Type.Int (g env e2);
	Type.Unit
    | Get(e1, e2) ->
	let t = Type.Var(ref None) in
	unify (Type.Array(t)) (g env e1);
	unify Type.Int (g env e2);
	t
    | Let(x, e1, e2) ->
	unify (snd x) (g env e1);
	g (M.add (fst x) (snd x) env) e2
    | LetRec(fundefs, e2) ->
	let env = M.adds (List.map (fun fundef -> fundef.name) fundefs) env in
	List.iter
	  (fun { name = ft; args = yts; body = e1 } ->
	    unify (snd ft) (Type.Fun(List.map snd yts, g (M.adds yts env) e1)))
	  fundefs;
	g env e2
    | Array(e1, e2) -> (* must be a primitive for "polymorphic" typing *)
	unify (g env e1) Type.Int;
	Type.Array(g env e2)
    | App(e1, e2s) ->
	let t = Type.Var(ref None) in
	unify (g env e1) (Type.Fun(List.map (g env) e2s, t));
	t
    | Int(_) -> Type.Int
    | Float(_) -> Type.Float
    | Unit -> Type.Unit)
  with Unify(t1, t2) -> raise (Error(deref_term e, deref_typ t1, deref_typ t2))

let f e =
  let xs = S.elements (fv e) in
  let env = M.adds (List.map gentyp xs) M.empty in
  unify Type.Int (g env e);
  initenv := M.map deref_typ env;
  deref_term e
@


1.4
log
@*** empty log message ***
@
text
@d1 3
a3 1
open Types
d6 12
a17 10
let rec occur r1 = function
  | TVar(r2) when r1 == r2 -> true
  | TVar(r2) ->
      (match !r2 with
      |	None -> false
      |	Some(t2) -> occur r1 t2)
  | TTuple(ts) -> List.exists (occur r1) ts
  | TArray(t) -> occur r1 t
  | TFun(t2s, t2') -> List.exists (occur r1) t2s || occur r1 t2'
  | _ -> false (* [XXX] error-prone *)
d19 1
d21 15
a35 13
  | TVar(r) ->
      (match !r with
      |	Some(t) ->
	  let t' = deref_typ t in
	  r := Some(t');
	  t'
      |	None -> TVar(r))
  | TInt -> TInt
  | TFloat -> TFloat
  | TTuple(ts) -> TTuple(List.map deref_typ ts)
  | TArray(t) -> TArray(deref_typ t)
  | TFun(t1s, t2) -> TFun(List.map deref_typ t1s, deref_typ t2)
let deref_id_typ (x, t) = (x, deref_typ t)
d37 15
a51 14
  | Var(x) -> Var(deref_id_typ x)
  | NegInt(x) -> NegInt(deref_id_sint x)
  | AddInt(x, y) -> AddInt(deref_id_typ x, deref_id_sint y)
  | SubInt(x, y) -> SubInt(deref_id_typ x, deref_id_sint y)
  | IfEqInt(x, y, e1, e2) ->
      IfEqInt(deref_id_typ x, deref_id_sint y, deref_term e1, deref_term e2)
  | IfLEInt(x, y, e1, e2) ->
      IfLEInt(deref_id_typ x, deref_id_sint y, deref_term e1, deref_term e2)
  | Tuple(xs) -> Tuple(List.map deref_id_typ xs)
  | LetTuple(xs, y, e) ->
      LetTuple(List.map deref_id_typ xs, deref_id_typ y, deref_term e)
  | Put(x, y, z, e) -> Put(deref_id_typ x, deref_id_typ y, deref_id_typ z, deref_term e)
  | Get(x, y) -> Get(deref_id_typ x, deref_id_typ y)
  | Let(x, e1, e2) -> Let(deref_id_typ x, deref_term e1, deref_term e2)
d55 2
a56 2
		 { name = deref_id_typ x;
		   args = List.map deref_id_typ ys;
d60 2
a61 1
  | App(x, ys) -> App(deref_id_typ x, List.map deref_id_typ ys)
d64 1
d66 8
a73 1
exception Unify of typ * typ
d76 19
a94 23
  match deref_typ t1, deref_typ t2 with
  | TVar(r1), TVar(r2) when r1 == r2 -> ()
  | TVar(r), t2 ->
      assert(!r = None);
      if occur r t2 then raise(Unify(TVar(r), t2));
      r := Some(t2)
  | t1, TVar(r) ->
      assert(!r = None);
      if occur r t1 then raise(Unify(t1, TVar(r)));
      r := Some(t1)
  | TInt, TInt -> ()
  | TFloat, TFloat -> ()
  | TTuple(t1s), TTuple(t2s) ->
      (try
	List.iter2 unify t1s t2s
      with Invalid_argument("List.iter2") ->
	raise(Unify(TTuple(t1s), TTuple(t2s))))
  | TArray(t1), TArray(t2) -> unify t1 t2
  | TFun(t1s, t1'), TFun(t2s, t2') ->
      (try
	List.iter2 unify t1s t2s
      with Invalid_argument("List.iter2") ->
	raise(Unify(TFun(t1s, t1'), TFun(t2s, t2'))));
d96 2
a97 1
  | t1, t2 -> raise(Unify(t1, t2)) (* [XXX] error-prone *)
d99 1
a99 7
let unify_id_sint = function
  | Ident(x) -> unify TInt (snd x)
  | SInt(_) -> ()

exception Error of t * typ * typ

let rec g e =
d102 28
a129 48
    | Var(Syntax.I(x), t)
      when x = "fadd" || x = "fsub" || x = "fmul" || x = "fdiv" ->
	unify t (TFun([TFloat; TFloat], TFloat));
	t
    | Var(Syntax.I("fneg"), t) ->
	unify t (TFun([TFloat], TFloat));
	t
    | Var(Syntax.I("imul"), t) ->
	unify t (TFun([TInt; TInt], TInt));
	t
    | Var(x) -> snd x
    | NegInt(x) ->
	unify_id_sint x;
	TInt
    | AddInt(x, y) ->
	unify (snd x) TInt;
	unify_id_sint y;
	TInt
    | SubInt(x, y) ->
	unify (snd x) TInt;
	unify_id_sint y;
	TInt
    | IfEqInt(x, y, e1, e2) ->
	unify (snd x) TInt;
	unify_id_sint y;
	let t1 = g e1 in
	let t2 = g e2 in
	unify t1 t2;
	t1
    | IfLEInt(x, y, e1, e2) ->
	unify (snd x) TInt;
	unify_id_sint y;
	let t1 = g e1 in
	let t2 = g e2 in
	unify t1 t2;
	t1
    | Tuple(xs) -> TTuple(List.map snd xs)
    | LetTuple(xs, y, e) ->
	unify (TTuple(List.map snd xs)) (snd y);
	g e
    | Put(x, y, z, e) ->
	unify (snd x) (TArray(snd z));
	unify (snd y) TInt;
	g e
    | Get(x, y) ->
	let t = TVar(ref None) in
	unify (snd x) (TArray(t));
	unify (snd y) TInt;
d132 2
a133 2
	unify (snd x) (g e1);
	g e2
d135 1
d137 2
a138 2
	  (fun { name = x; args = ys; body = e1 } ->
	    unify (snd x) (TFun(List.map snd ys, g e1)))
d140 7
a146 4
	g e2
    | App(x, ys) ->
	let t = TVar(ref None) in
	unify (snd x) (TFun(List.map snd ys, t));
d148 4
a151 3
    | Int(i) -> TInt
    | Float(g) -> TFloat)
  with Unify(t1, t2) -> raise(Error(deref_term e, deref_typ t1, deref_typ t2))
d154 4
a157 1
  unify TInt (g e);
@


1.3
log
@*** empty log message ***
@
text
@d1 2
a2 1
open KNormal
a14 31
exception Circularity of typ option ref * typ

let rec unify = function
  | TVar(r1), TVar(r2) when r1 == r2 -> ()
  | TVar(r), t2 ->
      (match !r with
      |	Some(t1) -> unify (t1, t2)
      |	None ->
	  if occur r t2 then raise(Circularity(r, t2));
	  r := Some(t2))
  | t1, TVar(r) -> unify (TVar(r), t1)
  | TInt, TInt -> ()
  | TFloat, TFloat -> ()
  | TTuple(t1s), TTuple(t2s) ->
      (try
	List.iter2 (fun t1 t2 -> unify (t1, t2)) t1s t2s
      with Invalid_argument("List.iter2") ->
	failwith "type error: tuple length mismatch")
  | TArray(t1), TArray(t2) -> unify (t1, t2)
  | TFun(t1s, t1'), TFun(t2s, t2') ->
      (try
	List.iter2 (fun t1 t2 -> unify (t1, t2)) t1s t2s
      with Invalid_argument("List.iter2") ->
	failwith "type error: argument length mismatch");
      unify (t1', t2')
  | _, _ -> failwith "type error: atom mismatch" (* [XXX] error-prone *)

let unify_id_sint = function
  | Ident(x) -> unify (TInt, snd x)
  | SInt(_) -> ()

d18 7
a24 6
      |	Some(t) -> deref_typ t
      |	None ->
	  (* [XXX] ad hoc workaround *)
	  Format.eprintf "detected uninstantiated type variable; assuming int@@.";
	  r := Some(TInt);
	  TInt)
d28 1
a28 5
  | t -> t (* [XXX] error-prone *)
let deref_id (x, t) = (x, deref_typ t)
let deref_id_sint = function
  | Ident(x, t) -> Ident(x, deref_typ t)
  | SInt(i) -> SInt(i)
d30 1
a30 1
  | Var(x) -> Var(deref_id x)
d32 2
a33 2
  | AddInt(x, y) -> AddInt(deref_id x, deref_id_sint y)
  | SubInt(x, y) -> SubInt(deref_id x, deref_id_sint y)
d35 1
a35 1
      IfEqInt(deref_id x, deref_id_sint y, deref_term e1, deref_term e2)
d37 2
a38 2
      IfLEInt(deref_id x, deref_id_sint y, deref_term e1, deref_term e2)
  | Tuple(xs) -> Tuple(List.map deref_id xs)
d40 4
a43 4
      LetTuple(List.map deref_id xs, deref_id y, deref_term e)
  | Put(x, y, z, e) -> Put(deref_id x, deref_id y, deref_id z, deref_term e)
  | Get(x, y) -> Get(deref_id x, deref_id y)
  | Let(x, e1, e2) -> Let(deref_id x, deref_term e1, deref_term e2)
d47 2
a48 2
		 { name = deref_id x;
		   args = List.map deref_id ys;
d52 1
a52 1
  | App(x, ys) -> App(deref_id x, List.map deref_id ys)
d56 103
a158 65
let rec g = function
  | Var(Syntax.I(x), t)
    when x = "fadd" || x = "fsub" || x = "fmul" || x = "fdiv" ->
      unify (t, TFun([TFloat; TFloat], TFloat));
      t
  | Var(Syntax.I("fneg"), t) ->
      unify (t, TFun([TFloat], TFloat));
      t
  | Var(Syntax.I("imul"), t) ->
      unify (t, TFun([TInt; TInt], TInt));
      t
  | Var(x) -> snd x
  | NegInt(x) ->
      unify_id_sint x;
      TInt
  | AddInt(x, y) ->
      unify (snd x, TInt);
      unify_id_sint y;
      TInt
  | SubInt(x, y) ->
      unify (snd x, TInt);
      unify_id_sint y;
      TInt
  | IfEqInt(x, y, e1, e2) ->
      unify (snd x, TInt);
      unify_id_sint y;
      let t1 = g e1 in
      let t2 = g e2 in
      unify (t1, t2);
      t1
  | IfLEInt(x, y, e1, e2) ->
      unify (snd x, TInt);
      unify_id_sint y;
      let t1 = g e1 in
      let t2 = g e2 in
      unify (t1, t2);
      t1
  | Tuple(xs) -> TTuple(List.map snd xs)
  | LetTuple(xs, y, e) ->
      unify (TTuple(List.map snd xs), snd y);
      g e
  | Put(x, y, z, e) ->
      unify (snd x, TArray(snd z));
      unify (snd y, TInt);
      g e
  | Get(x, y) ->
      let t = TVar(ref None) in
      unify (snd x, TArray(t));
      unify (snd y, TInt);
      t
  | Let(x, e1, e2) ->
      unify (snd x, g e1);
      g e2
  | LetRec(fundefs, e2) ->
      List.iter
	(fun { name = x; args = ys; body = e1 } ->
	  unify (snd x, TFun(List.map snd ys, g e1)))
	fundefs;
      g e2
  | App(x, ys) ->
      let t = TVar(ref None) in
      unify (snd x, TFun(List.map snd ys, t));
      t
  | Int(i) -> TInt
  | Float(g) -> TFloat
d161 1
a161 1
  unify (TInt, g e);
@


1.2
log
@*** empty log message ***
@
text
@d9 1
a9 1
  | TTuple(ts) -> List.exists (fun t -> occur r1 t) ts
d11 1
a11 1
  | TFun(t2s, t2') -> List.exists (fun t2 -> occur r1 t2) t2s || occur r1 t2'
d14 2
d17 1
d22 1
a22 1
	  if occur r t2 then failwith "type error: occur check failure";
d41 2
a42 2
let unify_ident_or_sint env = function
  | Ident(x) -> unify (TInt, FinMap.find x env)
d45 1
a45 1
let rec simplify = function
d48 1
a48 1
      |	Some(t) -> simplify t
d50 7
a56 5
	  Format.eprintf "detected an uninstantiated type variable@@.";
	  TVar(r))
  | TTuple(ts) -> TTuple(List.map (fun t -> simplify t) ts)
  | TArray(t) -> TArray(simplify t)
  | TFun(t1s, t2) -> TFun(List.map (fun t -> simplify t) t1s, simplify t2)
d58 30
d89 12
a100 2
let rec f' env = function
  | Var(x) -> FinMap.find x env
d102 1
a102 1
      unify_ident_or_sint env x;
d105 2
a106 2
      unify (FinMap.find x env, TInt);
      unify_ident_or_sint env y;
d109 2
a110 2
      unify (FinMap.find x env, TInt);
      unify_ident_or_sint env y;
d113 4
a116 4
      unify (FinMap.find x env, TInt);
      unify_ident_or_sint env y;
      let t1 = f' env e1 in
      let t2 = f' env e2 in
d120 4
a123 4
      unify (FinMap.find x env, TInt);
      unify_ident_or_sint env y;
      let t1 = f' env e1 in
      let t2 = f' env e2 in
d126 1
a126 2
  | Tuple(xs) ->
      TTuple(List.map (fun x -> FinMap.find x env) xs)
d128 10
a137 16
      let env' =
	List.fold_left
	  (fun env' (x, t) -> FinMap.add x t env')
	  env
	  xs in
      unify (TTuple(List.map snd xs),
	     FinMap.find y env);
      f' env' e
  | Put(t, x, y, z, e) ->
      unify (FinMap.find x env, TArray(t));
      unify (FinMap.find y env, TInt);
      unify (FinMap.find z env, t);
      f' env e
  | Get(t, x, y) ->
      unify (FinMap.find x env, TArray(t));
      unify (FinMap.find y env, TInt);
d139 3
a141 3
  | Let(x, t, e1, e2) ->
      unify (t, f' env e1);
      f' (FinMap.add x t env) e2
a142 9
      let env' =
	List.fold_left
	  (fun env' { name = (x, t);
		      args = _;
		      body = _ } ->
	    FinMap.add x t env')
	  env
	  fundefs in
      let t2 = f' env' e2 in
d144 2
a145 12
	(fun { name = (x, t);
	       args = ys;
	       body = e1 } ->
		 let env'' =
		   List.fold_left
		     (fun env'' (y, t) ->
		       FinMap.add y t env'')
		     env'
		     ys in
		 let t1 = f' env'' e1 in
		 unify (FinMap.find x env',
			TFun(List.map snd ys, t1)))
d147 1
a147 1
      t2
d149 3
a151 4
      let t1 = TVar(ref None) in
      let t2s = List.map (fun y -> FinMap.find y env) ys in
      unify (FinMap.find x env, TFun(t2s, t1));
      t1
d153 1
a153 1
  | Float(f') -> TFloat
d156 2
a157 6
  let env =
    Syntax.IdSet.fold
      (fun x env -> FinMap.add x (TVar(ref None)) env)
      (fv e)
      FinMap.empty in
  f' env e
@


1.1
log
@Initial revision
@
text
@a0 1
(*
a2 26
type t =
  | Var of ident
  | NegInt of ident_or_sint
  | AddInt of ident * ident_or_sint
  | SubInt of ident * ident_or_sint
  | IfEqInt of ident * ident_or_sint * t * t
  | IfLEInt of ident * ident_or_sint * t * t
  | Tuple of ident list
  | LetTuple of (ident * typ) list * ident * t
  | Put of typ * ident * ident * ident * t
  | Get of typ * ident * ident
  | Let of ident * typ * t * t
  | LetRec of fundef list * t (* mutually recursive functions *)
  | App of ident * ident list
  | Int of int
  | Float of float
and fundef = { name : ident * typ; args : (ident * typ) list; body : t }
*)
type typ =
  | TVar of typ option ref
  | TInt
  | TFloat
  | TTuple of typ list
  | TArray of typ
  | TFun of typ list * typ (* uncurried *)

d5 9
a13 1
(*
d19 1
a19 1
	  if occur r t2 then failwith "type error";
d28 1
a28 1
	failwith "type error")
d34 1
a34 1
	failwith "type error");
d36 1
a36 1
  | _, _ -> failwith "type error"
d42 15
a56 3
let rec f env = function
  | KNormal.Var(x) -> FinMap.find x env, Var(x)
  | KNormal.NegInt(x) ->
d58 2
a59 2
      TInt, NegInt(x)
  | KNormal.AddInt(x, y) ->
d62 2
a63 2
      TInt, AddInt(x, y)
  | KNormal.SubInt(x, y) ->
d66 2
a67 2
      TInt, AddInt(x, y)
  | KNormal.IfEqInt(x, y, e1, e2) ->
d70 2
a71 2
      let t1, e1' = f env e1 in
      let t2, e2' = f env e2 in
d73 2
a74 2
      t1, IfEqInt(x, y, e1', e2')
  | KNormal.IfLEInt(x, y, e1, e2) ->
d77 2
a78 2
      let t1, e1' = f env e1 in
      let t2, e2' = f env e2 in
d80 4
a83 4
      t1, IfLEInt(x, y, e1', e2')
  | KNormal.Tuple(xs) ->
      TTuple(List.map (fun x -> FinMap.find x env) xs), Tuple(xs)
  | KNormal.LetTuple(xs, y, e) ->
d86 1
a86 1
	  (fun env' x -> FinMap.add x (TVar(ref None)) env')
d89 1
a89 1
      unify (TTuple(List.map (fun x -> FinMap.find x env') xs),
d91 2
a92 4
      let t2, e' = f env' e in
      t2, LetTuple(List.map (fun x -> (x, FinMap.find x env')) xs, y, e')
  | KNormal.Put(x, y, z, e) ->
      let t = TVar(ref None) in
d96 2
a97 4
      let t', e' = f env e in
      t', Put(t, x, y, z, e')
  | KNormal.Get(x, y) ->
      let t = TVar(ref None) in
d100 5
a104 6
      t, Get(t, x, y)
  | KNormal.Let(x, e1, e2) ->
      let t1, e1' = f env e1 in
      let t2, e2' = f (FinMap.add x t1 env) e2 in
      t2, Let(x, t1, e1', e2')
  | KNormal.LetRec(fundefs, e2) ->
d107 4
a110 4
	  (fun env' { KNormal.name = x;
		      KNormal.args = _;
		      KNormal.body = _ } ->
	    FinMap.add x (TVar(ref None)) env')
d113 17
a129 25
      let t2, e2' = f env' e2 in
      t2, LetRec(List.map
		   (fun { KNormal.name = x;
			  KNormal.args = ys;
			  KNormal.body = e1 } ->
		     let env'' =
		       List.fold_left
			 (fun env'' y ->
			   FinMap.add y (TVar(ref None)) env'')
			 env'
			 ys in
		     let t1, e1' = f env'' e1 in
		     unify (FinMap.find x env',
			    TFun(List.map
				   (fun y -> FinMap.find y env'')
				   ys,
				 t1));
		     { name = (x, FinMap.find x env');
		       args = List.map
			 (fun y -> (y, FinMap.find y env''))
			 ys;
		       body = e1' })
		   fundefs,
		 e2')
  | KNormal.App(x, ys) ->
d133 11
a143 4
      t1, App(x, ys)
  | KNormal.Int(i) -> TInt, Int(i)
  | KNormal.Float(f) -> TFloat, Float(f)
*)
@
